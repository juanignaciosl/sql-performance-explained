<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=1024" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <title>SQL Performance Explained - Markus Winand | by Juan Ignacio Sánchez Lara @juanignaciosl</title>

    <meta name="description" content="Talk abour Markus Winand book: SQL Performance Explained" />
    <meta name="author" content="Juan Ignacio Sánchez Lara" />

    <link href='https://fonts.googleapis.com/css?family=Overlock|Overlock+SC|Fira+Mono:400,700|Open+Sans+Condensed:300' rel='stylesheet' type='text/css'>

    <link href="css/sql-performance-explained-impress.css" rel="stylesheet" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/default.min.css">
</head>

<body class="impress-not-supported">

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
</div>

<div id="impress">

    <div id="intro" class="step slide" data-x="-100000" data-scale="10">
      <div class="metadata">
        <h1>SQL Performance Explained</h1>
        <h2>Markus Winand</h2>

        <div class="author">
          <a href="https://juanignaciosl.github.io" class="name">Juan Ignacio Sánchez Lara</a>
          <a href="mailto:juanignaciosl@gmail.com">juanignaciosl@gmail.com</a>
          <a href="https://twitter.com/juanignaciosl">@juanignaciosl</a>
        </div>
      </div>
    </div>

    <div id="author" class="step juanignaciosl" data-x="-88000" data-scale="10">
      <div class="author">
        <h1><a href="https://juanignaciosl.github.io">Juan Ignacio Sánchez Lara</a></h1>
        <div class="metadata">
          <a href="mailto:juanignaciosl@gmail.com">juanignaciosl@gmail.com</a>
          <a href="https://twitter.com/juanignaciosl">@juanignaciosl</a>
        </div>

        <dl>
          <dt>UVa</dt><dd>I. T. Sistemas + I. Superior Informática</dd>
          <dt>AVA, Telefónica, Thales</dt><dd>Developer</dd>
          <dt>ITACyL</dt><dd>Software Analyst / Developer</dd>
          <dt>CExC</dt><dd>Developer, CTO ...</dd>
          <dt>CAG JCyL</dt><dd>Analyst</dd>
          <dt>Compiled Cubes: inCitee</dt><dd>Cofounder / iOS Developer</dd>
          <dt>CartoDB</dt><dd>Backend Developer</dd>
        </dl>
      </div>
      <p class="footnote">More information at <a href="http://www.juanignaciosl.com">personal</a> and (newborn) <a href="http://juanignaciosl.github.io">develop</a> blogs</p>
    </div>

    <div id="book-and-web" class="step" data-x="-76000"  data-scale="10">
      <img class="book-cover" src="img/sql-performance-explained-cover.png" alt="SQL Performance Explained (book cover)"/>
    </div>

    <div id="book-and-web-1" class="step" data-x="-76000" data-z="15000" data-scale="10">
      <a href="http://use-the-index-luke.com/">
        <img class="book-cover" src="img/use-the-index-luke.png" alt="Use the Index, Luke (web banner)"/>
      </a>

      <a href="http://use-the-index-luke.com/">Use the Index, Luke</a>

      <a href="https://www.postgresql.org/docs/9.5/static/index.html">
        <img class="book-cover" src="img/postgresql-banner.png" alt="PostgreSQL manual"/>
      </a>

      <a href="https://www.postgresql.org/docs/9.5/static/index.html">PostgreSQL Manual</a>
    </div>

    <div id="summary" class="step" data-x="-64000" data-scale="10">
      <h1>SQL Performance Explained</h1>
      <ol>
        <li>Book and web</li>
        <li>Anatomy of an Index</li>
        <li>The Where Clause</li>
        <li>Performance and Scalability</li>
        <li>The Join Operation</li>
        <li>Clustering Data</li>
        <li>Sorting and grouping</li>
        <li>Partial results</li>
        <li>Modifying data</li>
        <li>Execution plans</li>
      </ol>
    </div>

    <div id="b-trees" class="step section" data-x="-52000" data-scale="10">
      <h1>Anatomy of an Index</h1>
    </div>

    <div id="b-trees-1" class="step description" data-x="-52000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Anatomy of an Index</h1>
      <img src="img/f1.1-index-leaf-nodes.png" class="figure"/>
      <div class="figure-caption">Index leaf nodes</div>
    </div>

    <div id="b-trees-1-1" class="step description notes" data-x="-52000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Anatomy of an Index</h1>
      <ul>
        <li>
          Index leaf nodes
          <ul>
            <li>Doubly linked list</li>
            <li>(Doubly) Sorted: inside and among nodes</li>
          </ul>
        </li>
          <li>
            Database blocks
            <ul>
              <li>Same size</li>
              <li>Unsorted and unlinked</li>
            </ul>
          </li>
      </ul>
    </div>

    <div id="b-trees-2" class="step description" data-x="-52000" data-y="-15000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Anatomy of an Index</h1>
      <img src="img/f1.2-b-tree-structure.png" class="figure"/>
      <div class="figure-caption">Tree structure</div>
    </div>

    <div id="b-trees-2-1" class="step description notes" data-x="-52000" data-y="-15000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Anatomy of an Index</h1>
      <ul>
        <li>Branch node entry -> biggest value</li>
        <li><em>Balanced</em> search tree: tree depth equal at every position</li>
        <li>DB applies changes to the index and keeps the tree in balance</li>
        <li>... thus causing maintenance overhead for write operations</li>
      </ul>
    </div>

    <div id="b-trees-3" class="step description" data-x="-52000" data-y="-30000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Anatomy of an Index</h1>
      <img src="img/f1.3-b-tree-traversal.png" class="figure"/>
      <div class="figure-caption">Tree transversal</div>
    </div>

    <div id="b-trees-3-1" class="step description notes" data-x="-52000" data-y="-30000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Anatomy of an Index</h1>
      <h2>The first power of indexing</h1>
      <ul>
        <li>Tree balance allows accessing all elements with the same number of steps</li>
        <li>Logarithmic growth of the tree depth. Key tree depth factor: number of entries in each tree node. Databases often put hundreds.</li>
      </ul>
    </div>

    <div id="b-trees-4" class="step description" data-x="-52000" data-y="-30000" data-z="-15000" data-scale="10">
      <h1>B-Trees: slowness</h1>
      <ul>
        <li>
          Index lookup:
          <ol>
            <li>tree traversal</li>
            <li>following the leaf node chain</li>
            <li>fetching the table data</li>
          </ol>
        </li>
        <li>Database must read the next leaf node looking for more matching entries</li>
        <li>An index lookup needs to follow the leaf node chain</li>
      </ul>
    </div>

    <div id="where-clause" class="step section" data-x="-40000" data-scale="10">
      <h1>The Where Clause</h1>
    </div>

    <div id="where-clause-1" class="step description" data-x="-40000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>The Where Clause</h1>
      <pre><code class="ddl sql">
CREATE TABLE employees (
  employee_id integer not null PRIMARY key,
  subsidiary_id integer not null,
  first_name text,
  last_name text,
  date_of_birth DATE NOT NULL,
  phone_number character varying(1000) NOT NULL,
  enabled boolean default true
);

create unique index on employees (employee_id, subsidiary_id);

create index employees_last_name on employees(last_name);
      </code></pre>
    </div>

    <div id="where-clause-1c" class="step description" data-x="-40000" data-y="-15000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>The Where Clause</h1>
      <pre><code class="ddl sql">
        Table "public.employees"
Column     |          Type           |  Modifiers
---------------+-------------------------+--------------
employee_id   | integer                 | not null
subsidiary_id | integer                 | not null
first_name    | text                    |
last_name     | text                    |
date_of_birth | date                    | not null
phone_number  | character varying(1000) | not null
enabled       | boolean                 | default true
Indexes:
"employees_pkey" PRIMARY KEY, <strong>btree</strong> (employee_id)
"enabled_employees" <strong>btree</strong> (last_name) WHERE enabled = true
"employees_last_name" <strong>btree</strong> (last_name)
      </code></pre>
    </div>

    <div id="where-clause-3" class="step question" data-x="-40000" data-y="-30000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - equality</h1>
      <pre><code class="sql">
explain analyze SELECT first_name, last_name
FROM employees WHERE employee_id = 123;
      </code></pre>
    </div>

    <div id="where-clause-3b" class="step answer" data-x="-40000" data-y="-45000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - equality</h1>
      <pre><code class="sql">
explain analyze SELECT first_name, last_name
FROM employees WHERE employee_id = 123;
      </code></pre>
      <pre><code class="sql plan">
<strong>Index Scan</strong> using employees_pkey on employees
    (cost=0.29..8.31 rows=1 width=16)
    (actual time=0.009..0.010 rows=1 loops=1)
Index Cond: (employee_id = 123)
Planning time: 0.310 ms
Execution time: 0.051 ms
      </code></pre>
    </div>

    <div id="where-clause-4" class="step question" data-x="-40000" data-y="-60000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - multiple columns</h1>
      <pre><code class="sql">
explain analyze SELECT first_name, last_name
FROM employees WHERE employee_id = 111
    and subsidiary_id = 333;
      </code></pre>
    </div>

    <div id="where-clause-4b" class="step answer" data-x="-40000" data-y="-60000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - multiple columns</h1>
      <pre><code class="sql">
explain analyze SELECT first_name, last_name
FROM employees WHERE employee_id = 111
    and subsidiary_id = 333;
      </code></pre>
      <pre><code class="sql plan">
<strong>Index Scan</strong> using employees_employee_id_subsidiary_id_idx
    on employees (cost=0.29..8.31 rows=1 width=16)
    (actual time=0.023..0.025 rows=1 loops=1)
Index Cond: ((employee_id = 111) AND (subsidiary_id = 333))
Planning time: 0.130 ms
Execution time: 0.056 ms
      </code></pre>
    </div>

    <div id="where-clause-5" class="step question" data-x="-40000" data-y="-75000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - multiple columns</h1>
      <pre><code class="sql">
explain analyze SELECT first_name, last_name
FROM employees WHERE subsidiary_id = 333;
      </code></pre>
    </div>

    <div id="where-clause-5b" class="step answer wtf" data-x="-40000" data-y="-75000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - multiple columns</h1>
      <pre><code class="sql">
explain analyze SELECT first_name, last_name
FROM employees WHERE subsidiary_id = 333;
      </code></pre>
      <pre><code class="sql plan">
<strong class="wtfit">Index Scan</strong> using employees_employee_id_subsidiary_id_idx
    on employees (cost=0.29..1858.30 rows=1 width=16)
    (actual time=0.034..3.498 rows=1 loops=1)
  Index Cond: (subsidiary_id = 333)
Planning time: 0.101 ms
Execution time: 3.527 ms
      </code></pre>
    </div>

    <div id="where-clause-5c" class="step answer wtf" data-x="-40000" data-y="-75000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - multiple columns</h1>
      <pre><code class="sql">
explain analyze SELECT first_name, last_name
FROM employees WHERE subsidiary_id = 333;
      </code></pre>
      <pre><code class="sql plan">
<strong class="wtfit">Index Scan</strong> using employees_employee_id_subsidiary_id_idx
    on employees (cost=0.29..1858.30 rows=1 width=16)
    (actual time=0.034..3.498 rows=1 loops=1)
  Index Cond: (subsidiary_id = 333)
Planning time: 0.101 ms
Execution time: 3.527 ms
      </code></pre>
      <blockquote class="explanation">
        <p>A multicolumn B-tree index can be used with query conditions that involve any subset of the index's columns,
        but the index is most efficient when there are constraints on the leading (leftmost) columns.</p>
        <a class="source" href="https://www.postgresql.org/docs/9.5/static/indexes-multicolumn.html">PostgreSQL manual</a>
      </blockquote>
    </div>

    <div id="where-clause-8" class="step question" data-x="-40000" data-y="-90000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - multiple columns</h1>
      <pre><code class="sql">
select * from employees where date_of_birth > TO_DATE($1, 'YYYY-MM-DD')
    and date_of_birth < TO_DATE($2, 'YYYY-MM-DD') and subsidiary_id = $3;
      </code></pre>
      <pre><code class="sql">
create index employees_date on
    employees(date_of_birth, subsidiary_id);
      </code></pre>
      <pre><code class="sql">
create index employees_date on
    employees(subsidiary_id, date_of_birth);
      </code></pre>
    </div>

    <div id="where-clause-8b" class="step question" data-x="-40000" data-y="-105000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - multiple columns</h1>
      <img src="img/f2.2-index-range.png" class="figure"/>
    </div>

    <div id="where-clause-8c" class="step question" data-x="-40000" data-y="-120000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - multiple columns</h1>
      <img src="img/f2.3-index-range.png" class="figure"/>
    </div>

    <div id="where-clause-8d" class="step question compressed" data-x="-40000" data-y="-135000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - multiple columns</h1>
      <pre><code class="sql">
Bitmap Heap Scan on employees
    (cost=<strong>14.54..22.28</strong> rows=2 width=592) (actual time=0.069..0.071 rows=4 loops=1)
  Recheck Cond: ((date_of_birth > '1082-01-01'::date)
      AND (date_of_birth < '1083-01-01'::date) AND (subsidiary_id = 50))
  Heap Blocks: exact=3
  ->  Bitmap Index Scan on employees_date  (cost=0.00..14.54 rows=2 width=0)
      (actual time=0.064..0.064 rows=4 loops=1)
        Index Cond: ((date_of_birth > '1082-01-01'::date)
            AND (date_of_birth < '1083-01-01'::date) AND (subsidiary_id = 50))
Planning time: 0.365 ms
Execution time: 0.099 ms
      </code></pre>
      <pre><code class="sql">
Bitmap Heap Scan on employees
    (cost=<strong>4.34..19.58</strong> rows=4 width=35) (actual time=0.045..0.051 rows=4 loops=1)
  Recheck Cond: ((subsidiary_id = 50) AND (date_of_birth > '1082-01-01'::date)
      AND (date_of_birth < '1083-01-01'::date))
  Heap Blocks: exact=3
  ->  Bitmap Index Scan on employees_date  (cost=0.00..4.34 rows=4 width=0)
      (actual time=0.037..0.037 rows=4 loops=1)
        Index Cond: ((subsidiary_id = 50) AND (date_of_birth > '1082-01-01'::date)
            AND (date_of_birth < '1083-01-01'::date))
Planning time: 0.481 ms
Execution time: 0.084 ms
      </code></pre>
    </div>

    <div id="where-clause-8d-2" class="step answer compressed" data-x="-40000" data-y="-135000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - multiple columns</h1>
      <pre><code class="sql">
Bitmap Heap Scan on employees
    (cost=<strong>14.54..22.28</strong> rows=2 width=592) (actual time=0.069..0.071 rows=4 loops=1)
  Recheck Cond: ((date_of_birth > '1082-01-01'::date)
      AND (date_of_birth < '1083-01-01'::date) AND (subsidiary_id = 50))
  Heap Blocks: exact=3
  ->  Bitmap Index Scan on employees_date  (cost=0.00..14.54 rows=2 width=0)
      (actual time=0.064..0.064 rows=4 loops=1)
        Index Cond: ((date_of_birth > '1082-01-01'::date)
            AND (date_of_birth < '1083-01-01'::date) AND (subsidiary_id = 50))
Planning time: 0.365 ms
Execution time: 0.099 ms
      </code></pre>
      <pre><code class="sql">
Bitmap Heap Scan on employees
    (cost=<strong>4.34..19.58</strong> rows=4 width=35) (actual time=0.045..0.051 rows=4 loops=1)
  Recheck Cond: ((subsidiary_id = 50) AND (date_of_birth > '1082-01-01'::date)
      AND (date_of_birth < '1083-01-01'::date))
  Heap Blocks: exact=3
  ->  Bitmap Index Scan on employees_date  (cost=0.00..4.34 rows=4 width=0)
      (actual time=0.037..0.037 rows=4 loops=1)
        Index Cond: ((subsidiary_id = 50) AND (date_of_birth > '1082-01-01'::date)
            AND (date_of_birth < '1083-01-01'::date))
Planning time: 0.481 ms
Execution time: 0.084 ms
      </code></pre>
      <blockquote class="explanation">
        The child plan node visits an index to find the locations
        of rows matching the index condition, and then the upper plan node actually fetches those rows from the table
        itself. Fetching rows separately is much more expensive than reading them sequentially, but because not all the
        pages of the table have to be visited, this is still cheaper than a sequential scan.
        <a class="source" href="https://www.postgresql.org/docs/9.5/static/using-explain.html#USING-EXPLAIN-ANALYZE">PostgreSQL manual</a>
      </blockquote>
    </div>

    <div id="where-clause-6" class="step question" data-x="-40000" data-y="-150000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - functions</h1>
      <pre><code class="sql">
explain analyze SELECT first_name, last_name
FROM employees WHERE last_name = 'LN 38'
      </code></pre>
      <pre><code class="sql">
<strong>Index Scan</strong> using employees_last_name on employees
    (cost=0.42..8.44 rows=1 width=16)
    (actual time=0.049..0.049 rows=1 loops=1)
  Index Cond: (last_name = 'LN 38'::text)
Planning time: 0.286 ms
Execution time: 0.082 ms
      </code></pre>
    </div>

    <div id="where-clause-6b" class="step answer" data-x="-40000" data-y="-165000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - functions</h1>
      <pre><code class="sql">
explain analyze SELECT first_name, last_name
FROM employees WHERE upper(last_name) = 'LN 38'
      </code></pre>
      <pre><code class="sql plan">
<strong>Seq Scan</strong> on employees
    (cost=0.00..2334.00 rows=500 width=16)
    (actual time=0.048..46.647 rows=1 loops=1)
Filter: (upper(last_name) = 'LN 38'::text)
Rows Removed by Filter: 99999
Planning time: 0.092 ms
Execution time: 46.672 ms
      </code></pre>
    </div>

    <div id="where-clause-6d" class="step question" data-x="-40000" data-y="-180000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - functions</h1>
      <pre><code class="sql">
create index employees_upper_last_name
    on employees(<strong>upper(last_name)</strong>);
      </code></pre>
    </div>

    <div id="where-clause-6e" class="step answer" data-x="-40000" data-y="-180000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - functions</h1>
      <pre><code class="sql">
explain analyze SELECT first_name, last_name
FROM employees WHERE upper(last_name) = 'LN 38'
      </code></pre>
      <pre><code class="sql plan">
<strong>Bitmap Heap Scan</strong> on employees
    (cost=12.29..775.05 rows=500 width=16)
    (actual time=0.070..0.070 rows=1 loops=1)
  Recheck Cond: (upper(last_name) = 'LN 38'::text)
  Heap Blocks: exact=1
  ->  Bitmap Index Scan on employees_upper_last_name
            (cost=0.00..12.17 rows=500 width=0)
            (actual time=0.065..0.065 rows=1 loops=1)
        Index Cond: (upper(last_name) = 'LN 38'::text)
Planning time: 0.360 ms
Execution time: 0.091 ms
      </code></pre>
    </div>

    <div id="where-clause-6f" class="step question compressed" data-x="-40000" data-y="-195000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - functions</h1>
      <pre><code class="sql">
explain analyze select * from employees where employee_id = 5;
      </code></pre>
      <pre><code class="sql">
explain analyze select * from employees where employee_id + 1 = 6;
      </code></pre>
    </div>

    <div id="where-clause-6g" class="step answer compressed" data-x="-40000" data-y="-195000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - functions</h1>
      <pre><code class="sql">
explain analyze select * from employees where employee_id = 5;
      </code></pre>
      <pre><code class="sql">
<strong>Index Scan</strong> using employees_pkey on employees  (cost=0.29..8.31 rows=1 width=36) (actual time=0.014..0.015 rows=1 loops=1)
 Index Cond: (employee_id = 5)
Planning time: 0.075 ms
Execution time: 0.034 ms
      </code></pre>
      <pre><code class="sql">
explain analyze select * from employees where employee_id + 1 = 6;
      </code></pre>
      <pre><code class="sql">
<strong>Seq Scan</strong> on employees  (cost=0.00..2434.00 rows=500 width=36) (actual time=0.014..15.385 rows=1 loops=1)
 Filter: ((employee_id + 1) = 6)
 Rows Removed by Filter: 99999
Planning time: 0.066 ms
Execution time: 15.407 ms
      </code></pre>
    </div>

    <div id="where-clause-9" class="step description" data-x="-40000" data-y="-210000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - partial indexes</h1>
      <h2>Partial indexes</h2>
      <pre><code class="sql">
create index enabled_employees on employees(last_name)
    where enabled = 't';
      </code></pre>
    </div>

    <div id="where-clause-10" class="step description" data-x="-40000" data-y="-225000" data-z="-15000" data-rotate-x="-90" data-scale="10">
      <h1>Where clause: indexes - parameterized queries</h1>
      <pre><code class="java">
int subsidiary_id;
PreparedStatement command = connection.prepareStatement(
  "select first_name from employees where subsidiary_id = ?"
);
command.setInt(1, subsidiary_id);
      </code></pre>
      <ul>
        <li>Prevents SQL injection</li>
        <li>
          Executing exactly same statement multiple times uses <strong>execution plan cache</strong>.
          The same SQL statement with different values is treated like different statements, recreating the execution plan.
        </li>
      </ul>
    </div>

    <div id="where-clause-conclusion" class="step question conclusion" data-x="-40000" data-z="-15000" data-y="-225000" data-scale="10">
      <h1>Where clause: indexes - wrapping it up</h1>
      <ul>
        <li>Master <code>explain plan</code></li>
        <li>Avoid redundant indexes</li>
        <li>Avoid Seq Scan</li>
        <li>Keep an eye on queries and ORMs for function indexes</li>
        <li>... since functions and transformations prevent index usage</li>
        <li>Index equality before ranges</li>
        <li>One multiple index is faster than two</li>
        <li>Parameterize as much as possible</li>
      </ul>
    </div>

    <div id="where-clause-conclusion-1" class="step answer conclusion" data-x="-40000" data-z="-15000" data-y="-225000" data-scale="10">
      <h1>Where clause: indexes - wrapping it up</h1>
      <ul>
        <li>Master <code>explain plan</code></li>
        <li>Avoid redundant indexes</li>
        <li>Avoid Seq Scan</li>
        <li>Keep an eye on queries and ORMs for function indexes</li>
        <li>... since functions and transformations prevent index usage</li>
        <li>Index equality before ranges</li>
        <li>One multiple index is faster than two</li>
        <li>Parameterize as much as possible</li>
        <li><strong>Disclaimer: actual results depend on data and filters</strong></li>
      </ul>
    </div>

    <div id="performance" class="step section" data-x="-28000" data-scale="10">
      <h1>Performance and<br>Scalability</h1>
    </div>

    <div id="performance-1" class="step description" data-x="-28000" data-y="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Performance and Scalability</h1>
      <img src="img/f3.2-scalability-by-data-volume.png" class="figure"/>
      <div class="figure-caption">Scalability by data volume</div>
    </div>

    <div id="join" class="step section" data-x="-52000" data-y="8000" data-scale="10">
      <h1>The Join Operation</h1>
    </div>

    <div id="join-1" class="step description" data-x="-52000" data-y="8000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>The Join Operation</h1>
      <ul>
        <li>Normalized -> Denormalized</li>
        <li>2 tables => 1 step (corollary: +2 tables => +1 step)</li>
        <li>Tables are pipelined, there's no intermediate materialization</li>
        <li>The more complicated the query, the harder the optimization, use bind variables!</li>
        <li>Three basic algorithms: nested loops, hash join and sort merge</li>
      </ul>
      <div class="footnote"><a href="https://www.postgresql.org/docs/9.5/static/planner-optimizer.html">PostgreSQL details</a></div>
    </div>

    <div id="join-nested-loops" class="step question" data-x="-52000" data-y="-7000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>The Join Operation: Nested Loops</h1>
      <ul>
        <li><strong>The right relation is scanned once for every row found in the left one</strong></li>
        <li>Analogous to ORMs N+1 issue. Corollary: get to know your ORM and take control of joins</li>
        <li>Requires indexing of the join columns</li>
      </ul>
    </div>

    <div id="join-nested-loops-1" class="step answer" data-x="-52000" data-y="-7000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>The Join Operation: Nested Loops</h1>
      <ul>
        <li><strong>The right relation is scanned once for every row found in the left one</strong></li>
        <li>Analogous to ORMs N+1 issue. Corollary: get to know your ORM and take control of joins</li>
        <li>Requires indexing of the join columns</li>
      </ul>
      <ul class="conclusion">
        <li>Good performance if the driving query returns a small result set</li>
        <li>Downside: many B-tree traversals when executing the inner query</li>
      </ul>
    </div>

    <div id="join-hash-join" class="step question" data-x="-52000" data-y="-22000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>The Join Operation: Hash Join</h1>
      <ul>
        <li><strong>The right relation is first scanned and loaded into a hash table, using its join attributes as hash keys. Next the left relation is scanned and the appropriate values of every row found are used as hash keys to locate the matching rows in the table</strong></li>
        <li>You can improve hash join performance by selecting fewer columns</li>
        <li>There is no need to index the join columns. Indexing independent where predicates improve performance</li>
      </ul>
    </div>

    <div id="join-hash-join-1" class="step answer" data-x="-52000" data-y="-22000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>The Join Operation: Hash Join</h1>
      <ul>
        <li><strong>The right relation is first scanned and loaded into a hash table, using its join attributes as hash keys. Next the left relation is scanned and the appropriate values of every row found are used as hash keys to locate the matching rows in the table</strong></li>
        <li>You can improve hash join performance by selecting fewer columns</li>
        <li>There is no need to index the join columns. Indexing independent where predicates improve performance</li>
      </ul>
      <ul class="conclusion">
        <li>Only one scan per table</li>
        <li>Symmetric</li>
      </ul>
    </div>

    <div id="join-sort-merge" class="step question" data-x="-52000" data-y="-37000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>The Join Operation: Sort Merge</h1>
      <ul>
        <li>Each relation is sorted on the join attributes before the join starts. Then the two relations are scanned in parallel, and matching rows are combined to form join rows</li>
        <li>Only one scan per table</li>
      </ul>
    </div>

    <div id="join-sort-merge" class="step answer" data-x="-52000" data-y="-37000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>The Join Operation: Sort Merge</h1>
      <ul>
        <li>Each relation is sorted on the join attributes before the join starts. Then the two relations are scanned in parallel, and matching rows are combined to form join rows</li>
        <li>Only one scan per table</li>
      </ul>
      <ul class="conclusion">
        <li>Good for outer joins</li>
        <li>Good if input is sorted</li>
      </ul>
    </div>

    <div id="clustering" class="step section" data-x="-40000" data-y="8000" data-scale="10">
      <h1>Clustering Data</h1>
      <h2>The Second Power of Indexing</h2>
    </div>

    <div id="clustering-1" class="step description" data-x="-40000" data-y="8000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Clustering Data: Index Filter Predicates</h1>
      <dl>
        <dt>Clustering data</dt><dd>Store consecutively accessed data closely so thatit requires fewer IO operations</dd>
      </dl>
      <ul>
        <li>You can only sort the physical table with one order...</li>
        <li>... but you can create multiple indexes, with different orders</li>
        <li>Index filter predicates can be used not to improve range scan performance but to group consecutively accessed data together</li>
      </ul>
    </div>

    <div id="clustering-2-1" class="step description" data-x="-40000" data-y="-7000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Clustering Data: Index Filter Predicates</h1>
      <pre><code class="sql">
SELECT first_name, last_name, subsidiary_id, phone_number
FROM employees
WHERE subsidiary_id = ?
AND UPPER(last_name) LIKE '%INA%';
      </code></pre>
      <pre><code class="sql">
--------------------------------------------------------------
|Id | Operation | Name | Rows | Cost |
--------------------------------------------------------------
| 0 | SELECT STATEMENT | | 17 | 230 |
|*1 | TABLE ACCESS BY INDEX ROWID| EMPLOYEES | 17 | 230 |
|*2 | INDEX RANGE SCAN | EMPLOYEE_PK| 333 | 2 |
--------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
     1 - filter(UPPER("LAST_NAME") LIKE '%INA%')
     2 - access("SUBSIDIARY_ID"=TO_NUMBER(:A))
      </code></pre>
    </div>

    <div id="clustering-2-2" class="step question" data-x="-40000" data-y="-22000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Clustering Data: Index Filter Predicates</h1>
      <pre><code class="sql">
CREATE INDEX empsubupnam ON employees
    (subsidiary_id, UPPER(last_name));
      </code></pre>
    </div>

    <div id="clustering-2-2" class="step answer" data-x="-40000" data-y="-22000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Clustering Data: Index Filter Predicates</h1>
      <pre><code class="sql">
CREATE INDEX empsubupnam ON employees
    (subsidiary_id, UPPER(last_name));
      </code></pre>
      <pre><code class="sql">
--------------------------------------------------------------
|Id | Operation                   | Name       | Rows | Cost |
--------------------------------------------------------------
| 0 | SELECT STATEMENT            |            |   17 |   20 |
| 1 |  TABLE ACCESS BY INDEX ROWID| EMPLOYEES  |   17 |   20 |
|*2 |   INDEX RANGE SCAN          | EMPSUBUPNAM|   17 |    3 |
--------------------------------------------------------------
Predicate Information (identified by operation id):
---------------------------------------------------
   2 - access("SUBSIDIARY_ID"=TO_NUMBER(:A))
       filter(UPPER("LAST_NAME") LIKE '%INA%')
      </code></pre>
    </div>

    <div id="clustering-3-1" class="step question" data-x="-40000" data-y="-37000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Clustering Data: Index-only scan</h1>
      <ul>
        <li>Avoids accessing the table if the database has selected columns in the index itself</li>
      </ul>
    </div>

    <div id="clustering-3-2-1" class="step question" data-x="-40000" data-y="-52000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Clustering Data: Index-only scan</h1>
      <pre><code class="sql">
explain select subsidiary_id, last_name
    from employees where subsidiary_id < 5;
      </code></pre>
      <pre><code class="sql">
Bitmap Heap Scan on employees
    (cost=100.20..1089.58 rows=5150 width=12)
    (actual time=1.102..3.429 rows=5000 loops=1)
  Recheck Cond: (subsidiary_id < 5)
  Heap Blocks: exact=925
  ->  Bitmap Index Scan on employees_subsidiary_id_employee_id_idx
          (cost=0.00..98.92 rows=5150 width=0)
          (actual time=0.853..0.853 rows=5000 loops=1)
        Index Cond: (subsidiary_id < 5)
Planning time: 0.178 ms
Execution time: 3.867 ms
      </code></pre>
    </div>

    <div id="clustering-3-2-2" class="step question" data-x="-40000" data-y="-67000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Clustering Data: Index-only scan</h1>
      <pre><code class="sql">
CREATE INDEX empsubupnam ON employees
    (subsidiary_id, last_name);
      </code></pre>
    </div>

    <div id="clustering-3-2-3" class="step answer" data-x="-40000" data-y="-67000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Clustering Data: Index-only scan</h1>
      <pre><code class="sql">
CREATE INDEX empsubupnam ON employees
    (subsidiary_id, last_name);
      </code></pre>
      <pre><code class="sql">
explain select subsidiary_id, last_name
    from employees where subsidiary_id < 5;
      </code></pre>
      <pre><code class="sql">
<strong>Index Only</strong> Scan using empsubupnam on employees
      (cost=0.42..170.54 rows=5150 width=12)
      (actual time=0.109..0.912 rows=5000 loops=1)
 Index Cond: (subsidiary_id < 5)
 Heap Fetches: 0
Planning time: 0.091 ms
Execution time: 1.244 ms
      </code></pre>
    </div>

    <div id="clustering-4" class="step description" data-x="-40000" data-y="-82000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Clustering Data: Index-organized Tables</h1>
      <dl>
        <dt>Index-organized Tables (aka clustered index)</dt>
        <dd>Using an index as primary table store</dd>
        <dd>A B-tree index without a heap table</dd>
      </dl>
      <ul>
        <li>Saves the space for the heap structure</li>
        <li>Every access on a clustered index is automatically an index-only scan</li>
        <li><strong>Very</strong> inneficient on secondary indexes</li>
      </ul>
      <div class="footnote"><a href="https://www.postgresql.org/docs/9.5/static/sql-cluster.html">PostgreSQL CLUSTER</a></div>
    </div>

    <div id="clustering-4-1" class="step description" data-x="-40000" data-y="-97000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Clustering Data: Index-organized Tables</h1>
      <img src="img/f5.1-index-based-heap-table.png" class="figure"/>
      <div class="figure-caption">Index-based heap table</div>
    </div>

    <div id="clustering-4-2" class="step description" data-x="-40000" data-y="-112000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Clustering Data: Index-organized Tables</h1>
      <img src="img/f5.2-secondary-index-iot.png" class="figure"/>
      <div class="figure-caption">Secondary Index on an IOT</div>
    </div>

    <div id="clustering-conclusion" class="step question conclusion" data-x="-40000" data-y="-112000" data-z="-30000" data-scale="10">
      <h1>Clustering data - wrapping it up</h1>
      <ul>
        <li>Extend existing indexes to take advantage from filter predicates</li>
        <li>Extend existing indexes to take advantage from index-only scans</li>
        <li>Consider index-organized tables if you don't need more than one index</li>
      </ul>
    </div>

    <div id="sorting" class="step section" data-x="-28000" data-y="8000" data-scale="10">
      <h1>Sorting and grouping</h1>
    </div>

    <div id="sorting-1" class="step description" data-x="-28000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Sorting and grouping</h1>
      <ul>
        <li>Indexes provide ordered representations of the indexed data...</li>
        <li>...so we can use indexes to avoid the sort operation to satisfy an order by clause</li>
        <li>Indexed order by execution also returns the first results without processing all input data, it's executed in a pipelined manner</li>
      </ul>
    </div>

    <div id="sorting-2" class="step description" data-x="-28000" data-y="-15000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Sorting and grouping</h1>
      <pre><code class="sql">
explain analyze select * from sales order by sale_date;
      </code></pre>
      <pre><code class="sql">
Sort  (cost=122200.04..124450.04 rows=900000 width=24)
    (actual time=810.872..1007.881 rows=900000 loops=1)
 Sort Key: sale_date
 Sort Method: external merge  Disk: 29912kB
 ->  Seq Scan on sales
    (cost=0.00..14733.00 rows=900000 width=24)
    (actual time=0.006..113.583 rows=900000 loops=1)
Planning time: 0.112 ms
Execution time: 1074.673 ms
      </code></pre>
    </div>

    <div id="sorting-3" class="step question" data-x="-28000" data-y="-30000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Sorting and grouping</h1>
      <pre><code class="sql">
create index sales_date on sales(sale_date);
      </code></pre>
      <pre><code class="sql">
explain analyze select * from sales order by sale_date;
      </code></pre>
    </div>

    <div id="sorting-3-1" class="step answer" data-x="-28000" data-y="-30000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Sorting and grouping</h1>
      <pre><code class="sql">
create index sales_date on sales(sale_date);
      </code></pre>
      <pre><code class="sql">
explain analyze select * from sales order by sale_date;
      </code></pre>
      <pre><code class="sql">
Index Scan using sales_date on sales
    (cost=0.42..29120.43 rows=900000 width=24)
    (actual time=0.024..247.604 rows=900000 loops=1)
Planning time: 0.118 ms
Execution time: 315.568 ms
      </code></pre>
    </div>

    <div id="sorting-3-2" class="step question" data-x="-28000" data-y="-45000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Sorting and grouping</h1>
      <ul class="conclusion">
        <li class="good">Execution time: 1074.673 ms -> 315.568 ms :-) (x0.3)</li>
        <li class="neutral">Planning time: 0.112 ms -> 0.118 ms :-| (~=)</li>
      </ul>
    </div>

    <div id="sorting-3-3" class="step answer" data-x="-28000" data-y="-45000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Sorting and grouping</h1>
      <ul class="conclusion">
        <li class="good">Execution time: 1074.673 ms -> 315.568 ms :-) (x0.3)</li>
        <li class="neutral">Planning time: 0.112 ms -> 0.118 ms :-| (~=)</li>
        <li class="good">cost=122200.04..124450.04 -> 0.42..29120.43 :-) (x0.2)</li>
      </ul>
    </div>

    <div id="sorting-3-4" class="step answer" data-x="-28000" data-y="-45000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Sorting and grouping</h1>
      <ul class="conclusion">
        <li class="good">Execution time: 1074.673 ms -> 315.568 ms :-) (x0.3)</li>
        <li class="neutral">Planning time: 0.112 ms -> 0.118 ms :-| (~=)</li>
        <li class="good">cost=122200.04..124450.04 -> 0.42..29120.43 :-) (x0.2)</li>
      </ul>
      <p><strong>TL;DR: cost is not always an accurate measure</strong></p>
      <p>For a query that requires scanning a large fraction of the table, an explicit sort is likely to be faster than
        using an index because it requires less disk I/O due to following a sequential access pattern</p>
      <p>Cost can increased because <strong>clustering factor</strong> of the new index is worse</p>
    </div>

    <div id="clustering-factor" class="step section" data-x="-64000" data-y="8000" data-scale="10">
      <h1>[Clustering Factor]</h1>
    </div>

    <div id="clustering-factor-1" class="step description" data-x="-64000" data-y="-7000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>[Clustering Factor]</h1>
      <ul>
        <li>Performance benchmark</li>
        <li><strong>Correlation between index order and table order</strong></li>
        <li>Indirect measure of the probability that two succeeding index entries refer to the same table block</li>
        <li>Used by the optimizer to calculate the cost value of the TABLE ACCESS BY INDEX ROWID operation</li>
        <li>Good on chronological data, bad in random</li>
        <li>Indexes with good clustering factor don't benefit from performance advantage on index-only scan</li>
      </ul>
    </div>

    <div id="clustering-factor-2" class="step description" data-x="-64000" data-y="-22000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>[Clustering Factor]</h1>
      <pre><code class="sql">
select tablename, attname, correlation from pg_stats where
    schemaname = 'public';
      </pre></code>
      <pre><code class="sql">
 tablename |    attname    | correlation
-----------+---------------+-------------
 employees | date_of_birth |    0.976956
 employees | phone_number  |    0.801827
 employees | enabled       |    0.935313
 sales     | employee_id   |           1
 sales     | subsidiary_id |   0.0180426
 sales     | sale_id       |           1
 sales     | amount        |           1
 sales     | sale_date     |          -1
 employees | employee_id   |    0.976954
 employees | subsidiary_id |   -0.022466
 employees | first_name    |    0.801827
 employees | last_name     |    0.801827
      </pre></code>
    </div>

    <div id="sorting-3-5" class="step description" data-x="-28000" data-y="-60000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Sorting and grouping: asc/desc and nulls</h1>
      <ul>
        <li>Databases can read indexes in both directions</li>
        <img src="img/f6.5-database-order-features.png" class="figure"/>
        <div class="figure-caption">Database index sorting and null support features</div>
      </ul>
    </div>

    <div id="grouping-1" class="step question" data-x="-28000" data-y="-75000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Sorting and grouping: grouping</h1>
      Algorithms
      <ul class="alternatives">
        <li>Temporary hash</li>
        <li>Sort/group</li>
      </ul>
    </div>

    <div id="grouping-1-1" class="step answer" data-x="-28000" data-y="-75000" data-z="-30000" data-rotate-x="-90" data-scale="10">
      <h1>Sorting and grouping: grouping</h1>
      Algorithms
      <ul class="alternatives">
        <li>Temporary hash</li>
        <li>
          Sort/group
          <ul class="conclusion">
            <li class="good">With already sorted indexes</li>
          </ul>
        </li>
      </ul>
    </div>

    <div id="partial-results" class="step section" data-x="-52000" data-y="16000" data-scale="10">
      <h1>Partial results</h1>
    </div>

    <div id="partial-results-1" class="step question" data-x="-52000" data-y="16000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Partial results: retrieving top-n</h1>
      <ul class="conclusion">
        <li class="bad">Fetch only the first rows of a query and then closing the statement</li>
      </ul>
    </div>

    <div id="partial-results-1-1" class="step answer" data-x="-52000" data-y="16000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Partial results: retrieving top-n</h1>
      <ul class="conclusion">
        <li class="bad">Fetch only the first rows of a query and then closing the statement - the optimizer cannot foresee that when preparing the execution plan</li>
      </ul>
    </div>

    <div id="partial-results-1-2" class="step answer" data-x="-52000" data-y="16000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Partial results: retrieving top-n</h1>
      <ul class="conclusion">
        <li class="bad">Fetch only the first rows of a query and then closing the statement - the optimizer cannot foresee that when preparing the execution plan</li>
      </ul>

      PostgreSQL
      <pre><code class="sql">
LIMIT { count | ALL }
OFFSET start
      </pre></code>

SQL:2008
      <pre><code class="sql">
OFFSET start { ROW | ROWS }
FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY
      </pre></code>
    </div>

    <div id="partial-results-2-1" class="step question" data-x="-52000" data-y="1000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Partial results: paging</h1>
      <pre><code class="sql">
SELECT * FROM sales ORDER BY sale_date DESC OFFSET 10
FETCH NEXT 10 ROWS ONLY;
      </code></pre>
      <img src="img/f7.2-offset-method.png" class="figure" />
      <h2 class="figure-caption">The offset method</h2>
    </div>

    <div id="partial-results-2-2" class="step question" data-x="-52000" data-y="-14000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Partial results: paging</h1>
      <pre><code class="sql">
SELECT * FROM sales WHERE sale_date < ?
ORDER BY sale_date DESC FETCH FIRST 10 ROWS ONLY;
      </code></pre>
      <img src="img/f7.3-seek-method.png" class="figure" />
      <h2 class="figure-caption">The seek method</h2>
    </div>

    <div id="partial-results-2-3" class="step question" data-x="-52000" data-y="-29000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Partial results: paging</h1>
      <img src="img/f7.4-paging-performance.png" class="figure" />
      <h2 class="figure-caption">Offset vs seek performance</h2>
    </div>

    <div id="partial-results-2-4" class="step question" data-x="-52000" data-y="-44000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Partial results: paging</h1>
      <ul class="conclusion">
        <li>
          Offset method
          <ul class="conclusion">
            <li class="good">Simple and syntax support in SQL and ORMs</li>
            <li class="bad">Poor performance</li>
            <li class="bad">Pages drift on new items</li>
          </ul>
        </li>
        <li>
          Seek method
          <ul class="conclusion">
            <li class="bad">More complicated</li>
            <li class="good">Good performance</li>
            <li class="good">Pages don't drift on new items</li>
          </ul>
        </li>
      </ul>
    </div>

    <div id="modifying-data" class="step section" data-x="-40000" data-y="16000" data-scale="10">
      <h1>Modifying data</h1>
    </div>

    <div id="modifying-data-1" class="step question" data-x="-40000" data-y="16000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Modifying data: insert</h1>
      The more indexes a table has, the slower the execution becomes.
      <ol>
        <li>Store the row in any block with free space</li>
        <li>
          Update indexes
          <ol>
            <li>Find the correct leaf node</li>
            <li>Split leaf node if it hasn't free space</li>
          </ol>
        </li>
      </ol>
    </div>

    <div id="modifying-data-1-1" class="step answer" data-x="-40000" data-y="16000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Modifying data: insert</h1>
      The more indexes a table has, the slower the execution becomes.
      <ol>
        <li>Store the row in any block with free space</li>
        <li>
          Update indexes
          <ol>
            <li>Find the correct leaf node</li>
            <li>Split leaf node if it hasn't free space</li>
          </ol>
        </li>
      </ol>

      <ul class="conclusion">
        <li class="bad">Add the entry to each and every index</li>
        <li class="bad">Balance tree on split</li>
      </ul>
      <strong>Corollary: drop indexes on batch inserts</strong>
    </div>

    <div id="modifying-data-2" class="step question" data-x="-40000" data-y="1000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Modifying data: delete</h1>
      Similar to insert but, since it also searches, it takes advantage of indexes.
      <ol>
        <li>Find matches</li>
        <li>Delete the row</li>
        <li>Update indexes</li>
      </ol>
    </div>

    <div id="modifying-data-2-1" class="step answer" data-x="-40000" data-y="1000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Modifying data: delete</h1>
      Similar to insert but, since it also searches, it takes advantage of indexes.
      <ol>
        <li>Find matches</li>
        <li>Delete the row</li>
        <li>Update indexes</li>
      </ol>

      <ul class="conclusion">
        <li class="good">Takes advantage of indexes for search</li>
        <li class="bad">Removes the entry from each and every index</li>
        <li class="bad">Balance the tree on compacting</li>
      </ul>

      PS: keep MVCC in mind!!!
    </div>

    <div id="modifying-data-3" class="step question" data-x="-40000" data-y="-14000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Modifying data: update</h1>
      <ul>
        <li>Removes the old one and adds the new one</li>
        <li>Takes as much as delete + insert</li>
        <li>Sensitive to update only changes (ORMs!)</li>
      </ul>
    </div>

    <div id="execution-plans" class="step section" data-x="-28000" data-y="16000" data-scale="10">
      <h1>Execution plans</h1>
      <h2>PostgreSQL</h2>
    </div>

    <div id="execution-plans-1-1" class="step description" data-x="-28000" data-y="16000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans</h1>
      <pre><code class="sql">
PREPARE stmt(int) AS SELECT $1;
      </code></pre>
    </div>

    <div id="execution-plans-1-2" class="step answer" data-x="-28000" data-y="16000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans</h1>
      <pre><code class="sql">
PREPARE stmt(int) AS SELECT $1;
      </code></pre>
      <pre><code class="sql">
EXPLAIN EXECUTE stmt(1);
      </code></pre>
    </div>

    <div id="execution-plans-1-3" class="step answer" data-x="-28000" data-y="16000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans</h1>
      <pre><code class="sql">
PREPARE stmt(int) AS SELECT $1;
      </code></pre>
      <pre><code class="sql">
EXPLAIN EXECUTE stmt(1);
      </code></pre>
      <pre><code class="sql plan">
Result  (cost=0.00..0.01 rows=1 width=0)
      </code></pre>
      <dl>
        <dt>0.00</dt><dd>Startup cost</dd>
        <dt>0.01</dt><dd>Total cost for the execution if all rows are retrieved</dd>
      </dl>
    </div>

    <div id="execution-plans-1-4" class="step answer" data-x="-28000" data-y="16000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans</h1>
      <pre><code class="sql">
PREPARE stmt(int) AS SELECT $1;
      </code></pre>
      <pre><code class="sql">
EXPLAIN EXECUTE stmt(1);
      </code></pre>
      <pre><code class="sql plan">
Result  (cost=0.00..0.01 rows=1 width=0)
      </code></pre>
      <dl>
        <dt>0.00</dt><dd>Startup cost</dd>
        <dt>0.01</dt><dd>Total cost for the execution if all rows are retrieved</dd>
      </dl>
      <pre><code class="sql plan">
DEALLOCATE stmt;
      </code></pre>
    </div>

    <div id="execution-plans-2-1" class="step description" data-x="-28000" data-y="1000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans</h1>
      <pre><code class="sql">
EXPLAIN ANALYZE EXECUTE stmt(1);
      </code></pre>
Careful, It actually runs the query!
      <pre><code class="sql">
EXPLAIN ANALYZE UPDATE EMPLOYEES
    SET LAST_NAME = 'x' WHERE EMPLOYEE_ID = 1;
      </code></pre>
      <pre><code class="sql">
Update on employees  (cost=0.29..8.31 rows=1 width=34)
    (actual time=0.261..0.261 rows=0 loops=1)
  ->  Index Scan using employees_pkey on employees
      (cost=0.29..8.31 rows=1 width=34)
      (actual time=0.136..0.138 rows=1 loops=1)
        Index Cond: (employee_id = 1)
Planning time: 0.095 ms
Execution time: 0.297 ms
      </code></pre>
    </div>

    <div id="execution-plans-3-1" class="step description" data-x="-28000" data-y="-14000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans: index and table access</h1>
      <dl>
        <dt>Seq Scan</dt>
        <dt>Index Scan</dt>
        <dt>Index Only Scan</dt>
        <dt>Bitmap Index Scan / Bitmap Heap Scan / Recheck Cond</dt>
      </dl>
      <div class="footnote"><a href="https://www.postgresql.org/message-id/12553.1135634231@sss.pgh.pa.us">Bitmap Index Scan / Bitmap Heap Scan / Recheck Cond explanation</a></div>
    </div>

    <div id="execution-plans-3-2" class="step description" data-x="-28000" data-y="-29000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans: Join Operations</h1>
      <dl>
        <dt>Nested Loops</dt>
        <dt>Hash Join / Hash</dt>
        <dt>Merge Join</dt>
      </dl>
    </div>

    <div id="execution-plans-3-3" class="step description" data-x="-28000" data-y="-44000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans: Sorting and Grouping</h1>
      <dl>
        <dt>Sort / Sort Key</dt>
        <dt>GroupAggregate</dt>
        <dt>HashAggregate</dt>
      </dl>
    </div>

    <div id="execution-plans-3-4" class="step description" data-x="-28000" data-y="-59000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans: Top-N Queries</h1>
      <dl>
        <dt>Limit</dt>
        <dt>WindowAgg</dt>
      </dl>
    </div>

    <div id="execution-plans-3-5" class="step description" data-x="-28000" data-y="-74000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans: Distinguishing Access and Filter-Predicates</h1>
      <dl>
        <dt>Access Predicate (“Index Cond”)</dt>
        <dd>Start and stop conditions of the leaf node traversal</dd>
        <dt>Index Filter Predicate (“Index Cond”)</dt>
        <dd>Applied during the leaf node traversal only. They do not contribute to the start and stop conditions and do not narrow the scanned range</dd>
        <dt>Table level filter predicate (“Filter”)</dt>
        <dd>Predicates on columns that are not part of the index are evaluated on the table level</dd>
      </dl>
      <p>PostgreSQL execution plans do not show index access and filter predicates separately—both show up as “Index Cond”. That means the execution plan must be compared to the index definition to differentiate access predicates from index filter predicates.</p>
    </div>

    <div id="execution-plans-3-6" class="step answer" data-x="-28000" data-y="-74000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans: Distinguishing Access and Filter-Predicates</h1>
      <pre><code class="sql">
CREATE TABLE scale_data (
     section NUMERIC NOT NULL,
     id1     NUMERIC NOT NULL,
     id2     NUMERIC NOT NULL
  );
CREATE INDEX scale_data_key ON scale_data(section, id1);
      </code></pre>
    </div>

    <div id="execution-plans-3-7" class="step answer" data-x="-28000" data-y="-74000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans: Distinguishing Access and Filter-Predicates</h1>
      <pre><code class="sql">
PREPARE stmt(int) AS SELECT count(*)
                         FROM scale_data
                        WHERE section = 1
AND id2 = $1; EXPLAIN EXECUTE stmt(1);
      </code></pre>
      <pre><code class="sql plan">
 Aggregate  (cost=529346.31..529346.32 rows=1 width=0)
    Output: count(*)
    -> Index Scan using scale_data_key on scale_data
       (cost=0.00..529338.83 rows=2989 width=0)
       Index Cond: (scale_data.section = 1::numeric)
       Filter: (scale_data.id2 = ($1)::numeric)
      </code></pre>
    </div>

    <div id="execution-plans-3-7" class="step answer" data-x="-28000" data-y="-74000" data-z="-45000" data-rotate-x="-90" data-scale="10">
      <h1>Execution plans: Distinguishing Access and Filter-Predicates</h1>
      <pre><code class="sql">
CREATE INDEX scale_slow
            ON scale_data (section, id1, id2);
      </code></pre>
      <pre><code class="sql">
Aggregate (cost=14215.98..14215.99 rows=1 width=0)
    Output: count(*)
-> Index Scan using scale_slow on scale_data
(cost=0.00..14208.51 rows=2989 width=0)
Index Cond: (section = 1::numeric AND id2 = ($1)::numeric)
      </code></pre>
    </div>

    <div id="overview" class="step end" data-x="-40000" data-y="8000" data-z="1000" data-scale="30">
      <h1 class="highlight">Thank you very much!</h1>
      <p class="footnote">Slides & content available soon at <a href="http://juanignaciosl.github.io">juanignaciosl.github.io</a></p>
    </div>

</div>

<div class="hint">
    <p>Use a spacebar or arrow keys to navigate</p>
</div>
<script>
if ("ontouchstart" in document.documentElement) {
    document.querySelector(".hint").innerHTML = "<p>Tap on the left or right to navigate</p>";
}
</script>

<script src="js/impress.js"></script>
<script>impress().init();</script>

</body>
</html>
